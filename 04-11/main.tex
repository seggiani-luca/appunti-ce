
\documentclass[a4paper,11pt]{article}
\usepackage[a4paper, margin=8em]{geometry}

% usa i pacchetti per la scrittura in italiano
\usepackage[french,italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\frenchspacing 

% usa i pacchetti per la formattazione matematica
\usepackage{amsmath, amssymb, amsthm, amsfonts}

% usa altri pacchetti
\usepackage{gensymb}
\usepackage{hyperref}
\usepackage{standalone}

\usepackage{colortbl}

\usepackage{xstring}
\usepackage{karnaugh-map}

% imposta il titolo
\title{Appunti Calcolatori Elettronici}
\author{Luca Seggiani}
\date{2025}

% imposta lo stile
% usa helvetica
\usepackage[scaled]{helvet}
% usa palatino
\usepackage{palatino}
% usa un font monospazio guardabile
\usepackage{lmodern}

\renewcommand{\rmdefault}{ppl}
\renewcommand{\sfdefault}{phv}
\renewcommand{\ttdefault}{lmtt}

% circuiti
\usepackage{circuitikz}
\usetikzlibrary{babel}

% testo cerchiato
\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=2pt] (char) {#1};}}

% disponi il titolo
\makeatletter
\renewcommand{\maketitle} {
	\begin{center} 
		\begin{minipage}[t]{.8\textwidth}
			\textsf{\huge\bfseries \@title} 
		\end{minipage}%
		\begin{minipage}[t]{.2\textwidth}
			\raggedleft \vspace{-1.65em}
			\textsf{\small \@author} \vfill
			\textsf{\small \@date}
		\end{minipage}
		\par
	\end{center}

	\thispagestyle{empty}
	\pagestyle{fancy}
}
\makeatother

% disponi teoremi
\usepackage{tcolorbox}
\newtcolorbox[auto counter, number within=section]{theorem}[2][]{%
	colback=blue!10, 
	colframe=blue!40!black, 
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries, 
	title=Teorema~\thetcbcounter: #2, 
	#1
}

% disponi definizioni
\newtcolorbox[auto counter, number within=section]{definition}[2][]{%
	colback=red!10,
	colframe=red!40!black,
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries,
	title=Definizione~\thetcbcounter: #2,
	#1
}

% disponi codice
\usepackage{listings}
\usepackage[table]{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{codestyle}{
		backgroundcolor=\color{black!5}, 
		commentstyle=\color{codegreen},
		keywordstyle=\bfseries\color{magenta},
		numberstyle=\sffamily\tiny\color{black!60},
		stringstyle=\color{green!50!black},
		basicstyle=\ttfamily\footnotesize,
		breakatwhitespace=false,         
		breaklines=true,                 
		captionpos=b,                    
		keepspaces=true,                 
		numbers=left,                    
		numbersep=5pt,                  
		showspaces=false,                
		showstringspaces=false,
		showtabs=false,                  
		tabsize=2
}

\lstdefinestyle{shellstyle}{
		backgroundcolor=\color{black!5}, 
		basicstyle=\ttfamily\footnotesize\color{black}, 
		commentstyle=\color{black}, 
		keywordstyle=\color{black},
		numberstyle=\color{black!5},
		stringstyle=\color{black}, 
		showspaces=false,
		showstringspaces=false, 
		showtabs=false, 
		tabsize=2, 
		numbers=none, 
		breaklines=true
}


\lstdefinelanguage{assembler}{ 
  keywords={AAA, AAD, AAM, AAS, ADC, ADCB, ADCW, ADCL, ADD, ADDB, ADDW, ADDL, AND, ANDB, ANDW, ANDL,
        ARPL, BOUND, BSF, BSFL, BSFW, BSR, BSRL, BSRW, BSWAP, BT, BTC, BTCB, BTCW, BTCL, BTR, 
        BTRB, BTRW, BTRL, BTS, BTSB, BTSW, BTSL, CALL, CBW, CDQ, CLC, CLD, CLI, CLTS, CMC, CMP,
        CMPB, CMPW, CMPL, CMPS, CMPSB, CMPSD, CMPSW, CMPXCHG, CMPXCHGB, CMPXCHGW, CMPXCHGL,
        CMPXCHG8B, CPUID, CWDE, DAA, DAS, DEC, DECB, DECW, DECL, DIV, DIVB, DIVW, DIVL, ENTER,
        HLT, IDIV, IDIVB, IDIVW, IDIVL, IMUL, IMULB, IMULW, IMULL, IN, INB, INW, INL, INC, INCB,
        INCW, INCL, INS, INSB, INSD, INSW, INT, INT3, INTO, INVD, INVLPG, IRET, IRETD, JA, JAE,
        JB, JBE, JC, JCXZ, JE, JECXZ, JG, JGE, JL, JLE, JMP, JNA, JNAE, JNB, JNBE, JNC, JNE, JNG,
        JNGE, JNL, JNLE, JNO, JNP, JNS, JNZ, JO, JP, JPE, JPO, JS, JZ, LAHF, LAR, LCALL, LDS,
        LEA, LEAVE, LES, LFS, LGDT, LGS, LIDT, LMSW, LOCK, LODSB, LODSD, LODSW, LOOP, LOOPE,
        LOOPNE, LSL, LSS, LTR, MOV, MOVB, MOVW, MOVL, MOVSB, MOVSD, MOVSW, MOVSX, MOVSXB,
        MOVSXW, MOVSXL, MOVZX, MOVZXB, MOVZXW, MOVZXL, MUL, MULB, MULW, MULL, NEG, NEGB, NEGW,
        NEGL, NOP, NOT, NOTB, NOTW, NOTL, OR, ORB, ORW, ORL, OUT, OUTB, OUTW, OUTL, OUTSB, OUTSD,
        OUTSW, POP, POPL, POPW, POPB, POPA, POPAD, POPF, POPFD, PUSH, PUSHL, PUSHW, PUSHB, PUSHA, 
				PUSHAD, PUSHF, PUSHFD, RCL, RCLB, RCLW, MOVSL, MOVSB, MOVSW, STOSL, STOSB, STOSW, LODSB, LODSW,
				LODSL, INSB, INSW, INSL, OUTSB, OUTSL, OUTSW
        RCLL, RCR, RCRB, RCRW, RCRL, RDMSR, RDPMC, RDTSC, REP, REPE, REPNE, RET, ROL, ROLB, ROLW,
        ROLL, ROR, RORB, RORW, RORL, SAHF, SAL, SALB, SALW, SALL, SAR, SARB, SARW, SARL, SBB,
        SBBB, SBBW, SBBL, SCASB, SCASD, SCASW, SETA, SETAE, SETB, SETBE, SETC, SETE, SETG, SETGE,
        SETL, SETLE, SETNA, SETNAE, SETNB, SETNBE, SETNC, SETNE, SETNG, SETNGE, SETNL, SETNLE,
        SETNO, SETNP, SETNS, SETNZ, SETO, SETP, SETPE, SETPO, SETS, SETZ, SGDT, SHL, SHLB, SHLW,
        SHLL, SHLD, SHR, SHRB, SHRW, SHRL, SHRD, SIDT, SLDT, SMSW, STC, STD, STI, STOSB, STOSD,
        STOSW, STR, SUB, SUBB, SUBW, SUBL, TEST, TESTB, TESTW, TESTL, VERR, VERW, WAIT, WBINVD,
        XADD, XADDB, XADDW, XADDL, XCHG, XCHGB, XCHGW, XCHGL, XLAT, XLATB, XOR, XORB, XORW, XORL},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{\#},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{language=assembler, style=codestyle}

% disponi sezioni
\usepackage{titlesec}

\titleformat{\section}
	{\sffamily\Large\bfseries} 
	{\thesection}{1em}{} 
\titleformat{\subsection}
	{\sffamily\large\bfseries}   
	{\thesubsection}{1em}{} 
\titleformat{\subsubsection}
	{\sffamily\normalsize\bfseries} 
	{\thesubsubsection}{1em}{}

% tikz
\usepackage{tikz}

% float
\usepackage{float}

% grafici
\usepackage{pgfplots}
\pgfplotsset{width=10cm,compat=1.9}

% disponi alberi
\usepackage{forest}

\forestset{
	rectstyle/.style={
		for tree={rectangle,draw,font=\large\sffamily}
	},
	roundstyle/.style={
		for tree={circle,draw,font=\large}
	}
}

% disponi algoritmi
\usepackage{algorithm}
\usepackage{algorithmic}
\makeatletter
\renewcommand{\ALG@name}{Algoritmo}
\makeatother

% disponi numeri di pagina
\usepackage{fancyhdr}
\fancyhf{} 
\fancyfoot[L]{\sffamily{\thepage}}

\makeatletter
\fancyhead[L]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@title \ \@date}}} 
\fancyhead[R]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@author}}}
\makeatother

\begin{document}
% sezione (data)
\section{Lezione del 11-04-25}

% stili pagina
\thispagestyle{empty}
\pagestyle{fancy}

% testo
Riprendiamo il discorso dell'I/O nel kernel.

\subsection{Primitive di I/O}
L'ipotesi generale è che una primitiva di I/O vuole trasferire dati da e alla memoria o da e allo spazio di I/O.
La forma generica della primitive che vorremo fornire all'utente sarà quindi del tipo:
\begin{itemize}
	\item \textbf{Lettura:}
\begin{lstlisting}[language=C++, style=codestyle]
read_n(id, char* buf, natq quanti);
\end{lstlisting}
dove prendiamo la periferica \lstinline|id|, e la usiamo per leggere \lstinline|quanti| byte e inserirli nel buffer (in memoria condivisa) \lstinline|buf|;
	\item \textbf{Scrittura:}
\begin{lstlisting}[language=C++, style=codestyle]
write_n(id, const char* buf, natq quanti);
\end{lstlisting}
dove prendiamo la periferica \lstinline|id|, e ci scriviamo \lstinline|quanti| byte dal buffer (in memoria condivisa) \lstinline|buf|.
\end{itemize}

Avremo quindi che un certo processo $P_1$, a qualche punto della sua esecuzione, chiama una primitiva di I/O.
A questo punto il controllo passa al kernel, che si occupa quindi di gestire l'operazione, sfruttando prima di tutto le istruzioni privilegiate a cui ha accesso \lstinline|IN|, \lstinline|OUT|, ecc... e le possibilità di scheduling di cui dispone per eseguire, mentre attende per la sincronia col dispositivo, altri processi (mettendo quindi quello che aveva chiamato la primitiva in attesa).
Quando $P_1$ viene rimesso in esecuzione, non vede niente di diverso nel suo contesto privato, se non il fatto che il buffer contiene adesso l'input desiderato.

\par\smallskip

Le primitive di sistema che gestiscono un certo dispositivo prendono il nome, abbiamo detto, di \textbf{driver}.

\begin{enumerate}
	\item 
Per realizzare il meccanismo di \textbf{sincronizzazione} sfruttiamo \textit{semaforo}: vogliamo che il la primitiva di I/O chiami la \lstinline|sem_wait()| al momento dell'inizio dell'operazione di I/O, e che la \lstinline|sem_signal()| venga chiamata sullo stesso semaforo alla fine dell'operazione per segnalare che l'operazione è finita (dal driver stesso).

	\item
Per realizzare invece la \textbf{mutua esclusione} si sfrutta il procedimento inverso: si parte con un semaforo inizializzato a \lstinline|sem_wait()|, e successivamente ogni processo che inizia un'operazione di I/O ne prende un \textit{"gettone"}, restituendolo a termine operazione, così che nessun processo possa iniziare una operazione di I/O contemporaneamente a un altro.
\end{enumerate}

\subsubsection{Primitive nel kernel}
Avevamo visto che il problema era usare le \lstinline|sem_wait()| e le \lstinline|sem_signal()| lato kernel, in quanto queste effettivamente interrompono routine sistema e ne violano l'atomicità.

Vediamo però che, se ci limitiamo a non manipolare le strutture dati sistema nelle primitive \lstinline|read_n()| e \lstinline|write_n()|, non incappiamo nei rischi per cui avevamo introdotto l'atomicità delle routine sistema in primo luogo (le uniche a manipolare la lista processi saranno le \lstinline|read_n()| e \lstinline|write_n()|).

L'unico problema resterà il discorso del contesto, che verrebbe salvato così 2 volte.
Rimuoviamo allora le \lstinline|salva_stato| e \lstinline|carica_stato|.

Trasformiamo quindi le primitive di I/O in primitive effettivamente \textit{non atomiche}, che eseguono nello stesso contesto (a livello di registri) del processo chiamante.

\subsubsection{Driver}
Vediamo come si svolge la situazione lato driver.
Potremmo pensare iniziatutto di sfruttare un certo descrittore di \textit{dispositivo}, \lstinline|des_io|, realizzato ad esempio come:
\begin{lstlisting}[language=C++, style=codestyle]	
des_io {
	char* buf;
	natq quanti;

	// semafori
	natl mutex;
	natl sync;
};
\end{lstlisting}
cioè contenente tutte le informazioni necessarie al driver per soddisfare la richiesta del processo che ha richiesto l'I/O, scrivendo i dati ottenuti nel buffer \lstinline|buf| giusto all'indice \lstinline|quanti| (che incrementerà o decrementerà da solo) giusto.

\begin{itemize}
	\item \lstinline|buf| e \lstinline|quanti| vengono forniti alla primitiva di I/O e cambiano per ogni richiesta da parte dei processi.
	\item \lstinline|mutex| e \lstinline|sync| sono gli indici dei semafori e vengono inizializzati una sola volta per ogni dispositivo.
		In particolare, stando a quanto abbiamo detto nello scorso paragrafo, vorremo:
\begin{lstlisting}[language=C++, style=codestyle]	
// sync si inizializza a 0
if ( (ce->sync = sem_ini(0)) == 0xFFFFFFFF) { 
	flog(LOG_WARN, "ce%d: impossibile allocare sync", next_ce);
	break;
}
// mutex si inizializza a 1
if ( (ce->mutex = sem_ini(1)) == 0xFFFFFFFF) { 
	flog(LOG_WARN, "ce%d: impossibile allocare mutex", next_ce);
	break;
}
\end{lstlisting}
\end{itemize}

Notiamo che in ogni caso il buffer rappresenta i dati lato utente, cioè come vedremo contenuti nella memoria condivisa dei processi, e nulla riguardo al dispositivo vero e proprio: i suoi dati verranno ottenuti, a controllo d'interruzione, dalla primitiva stessa attraverso i suoi procedimenti specifici.
In particolare, il buffer della \lstinline|read_n| sarà quello dove il driver dovrà scrivere cosa legge così che il processo lo veda, mentre il buffer (costante) della \lstinline|write_n| sarà quello dove il driver dovrà leggere per restituire poi al dispositivo.

Chiamando \lstinline|proc| la primitiva che si occupa di realizzare la richiesta I/O (nell'esempio in 19.1, potrebbe essre sia \lstinline|read_n| che \lstinline|write_n|), e \lstinline|driver| la primitiva del driver, si ha che i semafori di un certo descrittore \lstinline|ce| si evolvono quindi come segue (in relazione alla lista di 19.1):
\begin{enumerate}
	\item 
	\lstinline|proc| aspetta che arrivi \lstinline|ce->mutex| (2);
	\item
	\lstinline|proc| prende \lstinline|ce->sync| e viene messo in attesa (1);
	\item
	\lstinline|driver| restituisce \lstinline|ce->sync| (1);
	\item
	\lstinline|proc| restituisce \lstinline|ce->mutex| (2)
\end{enumerate}
e che quindi \lstinline|proc| e \lstinline|driver| sono strutturati pressappoco come segue, prima \lstinline|proc|:
\begin{lstlisting}[language=C++, style=codestyle]	
extern "C" void proc(natl id, ...) {
	// ottieni ce
	sem_wait(ce->mutex); // (2)
	sem_wait(ce->sync); // (1)
	
	// qui saremo messi in attesa, e' compito di driver restituire ce->sync
	
	sem_signal(ce->mutex); // (2)
}
\end{lstlisting}
e poi \lstinline|driver|:
\begin{lstlisting}[language=C++, style=codestyle]	
extern "C" void driver() {
	// ottieni ce

	// intanto restituirai un byte
	ce->quanti--;

	if(ce-quanti == 0) {
		// appunto, restituiamo
		c_sem_signal(ce->sync); (1)
	}

	// qui gestiamo l'interruzione esterna del dispositivo
	// e restituiamo effettivamente il byte
}
\end{lstlisting}

Nei prossimi paragrafi andremo via via a definire i dettagli tecnici e raffinare l'implementazione.

\subsubsection{Driver e primitive}
La domanda è se il driver può chiamare le primitive semaforo che gestiscono i semafori di indice \lstinline|mutex| e \lstinline|sync|.
In particolare, avevamo detto che il driver avrà il compito di chiamare la \lstinline|sem_signal(sync)| per segnalare al processo che l'operazione di I/O è finita.
Abbiamo però il problema della \lstinline|salva_stato|, che andrà a sovrascrivere, quando chiamata da una routine sistema (e quindi anche da un driver) il contesto del processo in \lstinline|esecuzione| (che potrebbe essere arbitrario) con i valori correnti della routine sistema, facendo evidentemente danni. 

Potremmo allora pensare di usare direttamente la sua implementazione, cioè chiamare la \lstinline|c_sem_signal()|.
Il problema sarà che la \lstinline|c_sem_signal()| usa la \lstinline|sem_valido()| per controllare la validità del semaforo cercato, usando la \lstinline|liv_chiamante()|, che non sarebbe significativa se chiamata senza passare da un interruzione (sfrutta il CS salvato presumibilmente in pila dalla \lstinline|INT|).
In particolare, vediamo che si ha:
\begin{lstlisting}[language=C++, style=codestyle]	
extern "C" void c_sem_signal(natl sem)
{
	// una primitiva non deve mai fidarsi dei parametri
	if (!sem_valido(sem)) {
		flog(LOG_WARN, "semaforo errato: %u", sem);
		c_abort_p();
		return;
	}

	// corpo di esecuzione effettiva, alla 11.2.1 
}
\end{lstlisting}
percorrendo il backtrace al contrario:
\begin{lstlisting}[language=C++, style=codestyle]	
bool sem_valido(natl sem)
{
	// dal momento che i semafori non vengono mai deallocati,
	// un semaforo e' valido se e solo se il suo indice e' inferiore
	// al numero dei semafori allocati

	int liv = liv_chiamante(); // qui vogliamo distinguere il contesto
	return sem < sem_allocati_utente ||
		(liv == LIV_SISTEMA && sem - MAX_SEM < sem_allocati_sistema);
}
\end{lstlisting}
e infine:
\begin{lstlisting}[language=C++, style=codestyle]	
int liv_chiamante()
{
	// (ci aspettiamo che) salva_stato ha salvato il puntatore 
	// alla pila sistema subito dopo l'invocazione della INT
	natq* pila = ptr_cast<natq>(esecuzione->contesto[I_RSP]);

	// -> peccato che nessuno ha chiamato la salva_stato!
	//    siamo passati da c_sem_signal() e non a_sem_signal()

	// la seconda parola dalla cima della pila contiene il livello
	// di privilegio che aveva il processore prima della INT
	return pila[1] == SEL_CODICE_SISTEMA ? LIV_SISTEMA : LIV_UTENTE;
}
\end{lstlisting}

Saremo quindi costretti a replicare in qualche modo la \lstinline|c_sem_signal()| nel codice del driver, cioè dire:
\begin{lstlisting}[language=C++, style=codestyle]	
extern "C" void c_driver() {
	// ottieni ce

	// intanto restituirai un byte
	ce->quanti--;

	if(ce-quanti == 0) {
		// qui (!) facciamo la sem_signal()
		des_sem *s = &array_dess[ce->sync];

		s->counter = 0;
		des_proc* lavoro = rimozione_lista(s->pointer);
		inspronti();	// preemption
		inserimento_lista(pronti, lavoro);
		schedulatore();	// preemption
	}

	// qui gestiamo l'interruzione esterna del dispositivo
	// e restituiamo effettivamente il byte
}
\end{lstlisting}

In questo modo, il codice del driver dovrà essere effettivamente atomico (\lstinline|c_sem_signal()| manipola le liste di processi, che sono strutture dati sensibili).
Questo potrebbe essere problematico in quanto ci impedisce di gestire interruzioni innestate a priorità più alta.
Decidiamo di continuare con questa limitazione.

\subsubsection{Cavalli di Troia}
Altre questioni di sicurezza potrebbero riguardare i cosiddetti \textbf{cavalli di Troia}: un utente potrebbe sfruttare la \lstinline|write_n()| per scrivere in locazioni di memoria arbitrarie, dove lui da solo non avrebbe potuto scrivere.
Si rende quindi necessario controllare gli indirizzi passati alle primitive di I/O lato software.

Vediamo i problemi che vogliamo controllare:
\begin{itemize}
	\item Gli indirizzi potrebbero fare wraparound, costringendo il driver a saltare da $M_2$ a $M_1$, e quindi sovrascrivendo più memoria di quanta probabilmente si voleva impattare;
	\item Regioni di indirizzi virtuali (di per sé contigue) che potrebbero avere flag di scrivibilità non contigui (cioè si potrebbero incontrare flag di traduzioni modalità sistema o sola lettura);
	\item Indirizzi virtuali non tradotti, che quindi causerebbero page fault (e visto che abbiamo detto il driver deve essere atomico, non possiamo permetterci nessuna eccezione);
	\item Non vogliamo accedere alla memoria privata del processo richiedente l'I/O, perché l'albero di traduzione caricato al momento dell'esecuzione del driver non sarà sicuramente il suo (è stato messo in attesa dalla primitiva), ma quello di un altro processo (quello in \lstinline|esecuzione|) con la sua memoria privata (che sicuramente non vogliamo toccare). 
\end{itemize}

L'unica regione valida resta quindi quella che avevamo già detto, cioè la \textbf{memoria condivisa}.
Notiamo che questa era comunque una necessità, in quanto vogliamo che il processo passi per forza un buffer corrispondente ad un indirizzo in memoria condivisa, appunto perchè chiedere alla primitiva driver di scrivere nel suo spazio privato sarebbe complesso (a meno di non passare un indirizzo fisico, e quindi passare dalla finestra FM, cosà però abbastanza complicata dal punto di vista dei controlli).

Per tutti questi controlli, quindi, siamo quindi costretti a controllare tutte le traduzioni.

Scriveremo quindi un'apposita funzione di controllo del buffer del tipo:
\begin{lstlisting}[language=C++, style=codestyle]	
// restituisce true (nell'I_RAX del contesto) se la regione va bene,
// false altrimenti
extern "C" bool c_access(vaddr begin, natq dim, bool writeable, bool shared = true)
{
	esecuzione->contesto[I_RAX] = false;

	// l'intervallo e' valido?
	if (!tab_iter::valid_interval(begin, dim))
		return false;

	// siamo nella regione di memoria utente condivisa?
	if (shared && (!in_utn_c(begin) || (dim > 0 && !in_utn_c(begin + dim - 1))))
		return false;

	// usiamo un tab_iter per percorrere tutto il sottoalbero relativo
	// alla traduzione degli indirizzi nell'intervallo [begin, begin+dim).
	for (tab_iter it(esecuzione->cr3, begin, dim); it; it.next()) {
		tab_entry e = it.get_e();

		// interrompiamo il ciclo non appena troviamo qualcosa che non va
		if (!(e & BIT_P) || !(e & BIT_US) || (writeable && !(e & BIT_RW)))
			return false;
	}
	esecuzione->contesto[I_RAX] = true;
	return true;
}
\end{lstlisting}
che fa prima i controlli detti su intervallo e regione processi, e poi percorre l'intero albero di traduzione, controllando che ogni traduzione sia scrivibile.

\subsubsection{Implementazione di un driver}
Vediamo quindi l'implementazione di un semplice driver per un dispositivo fasullo cioè il dispositivo \textit{CE}, dotato di soli 3 registri (e relative porte):
\begin{table}[h!]
	\center
	\begin{tabular} { p{1.5cm} | p{7cm} }
		\lstinline|0x?? + 0| & \textbf{CTL}, \textit{Control Register} \\
		\lstinline|0x?? + 4| & \textbf{STR}, \textit{Status Register} \\
		\lstinline|0x?? + 8| & \textbf{RBR}, \textit{Receive Buffer Register} \\
	\end{tabular}
\end{table}

Il \lstinline|0x??| è dato dal fatto che il dispositivo è montato sul bus PCI, ergo per disporre i suoi registri nello spazio di I/O bisogna regolarne il \textbf{BAR}.

In ogni caso, il funzionamento del dispositivo è banale: si limita a controllare periodicamente CTL, e quando vi trova 1, stampare un carattere alfanumerico.

Disponiamo per tale dispositivo il descrittore:
\begin{lstlisting}[language=C++, style=codestyle]	
struct des_ce {
	// i registri, variabili perche in PCI
	ioaddr iCTL, iSTS, iRBR;

	// gia' visto
	char *buf;
	natl quanti;
	natl sync;
	natl mutex;
};
\end{lstlisting}

Avremo quindi una funzione \lstinline|ce_init()|, che viene lanciata all'avvio del kernel, e che si occupa di impostare il BAR e i descrittori dispositivo. 

A questo punto, forniremo all'utente la primitiva \lstinline|c_ceread_n()|, per la lettura:
\begin{lstlisting}[language=C++, style=codestyle]	
// questa non può toccare i descrittori di processo, praticamente e' una chiamata di funzione,
// quindi e' interrompibile (non atomica)
extern "C" void c_ceread_n(natl id, char *buf, natl quanti)
{
	if (id == id_ce) {
		flog(LOG_WARN, "ce non riconosciuto: %d", id);
		abort_p(); // e' quella normale, nessuno ha ancora chiamato salva_stato
	}

	if (!quanti)
		return;

	if (!c_access(reinterpret_cast<vaddr>(buf), quanti, true, false)) {
		flog(LOG_WARN, "buf non valido\n");
		abort_p();
	}

	des_ce *ce = ce;
	sem_wait(ce->mutex);
	ce->buf = buf;
	ce->quanti = quanti;
	outputb(1, ce->iCTL); // qui attivi 
	sem_wait(ce->sync);
	sem_signal(ce->mutex);
}
\end{lstlisting}

mentre imposteremo nella IDT una funzione assembly che chiama il seguente gestore per l'interruzione esterna associata a \textit{CE}:
\begin{lstlisting}[language=C++, style=codestyle]	
// questa e' atomica, e reimplementa in qualche modo sem_signal()
extern "C" void c_driver_ce(int id)
{
	// qui otteniamo il descrittore di dispositivo
	des_ce *ce = ce;
	ce->quanti--;

	// qui si termina se si e' finito
	if (ce->quanti == 0) {
		// qui disattiviamo le interruzioni
		outputb(0, ce->iCTL);
		
		// qui (!) facciamo la sem_signal()
		des_sem *s = &array_dess[ce->sync];

		s->counter = 0;
		des_proc* lavoro = rimozione_lista(s->pointer);
		inspronti();	// preemption
		inserimento_lista(pronti, lavoro);
		schedulatore();	// preemption
	}

	// qui gestiamo effettivamente il dispositivo 

	// questa va fatta dopo che disattivi le interruzioni,
	// altrimenti potresti avere un'altra interruzione sotto (nell'IRR)
	char b = inputb(ce->iRBR);
	*ce->buf = b;
	ce->buf++;
}
\end{lstlisting}
dove notiamo il dettaglio che la gestione del dispositivo si fa dopo aver disattivato, eventualmente, il dispositivo impostando CTL a 0.
In caso contrario, si potrebbe ottenere una nuova interruzione, messa in IRR dall'APIC, che andrebbe erroneamente a richiamare il driver una volta di troppo rispetto a quelle previste.

Lato assembler, il driver verrà impostato come segue:
\begin{lstlisting}[language=assembler, style=codestyle]	
% setup IDT
carica_gate	INTR_TIPO_CE	a_driver_ce	LIV_SISTEMA
\end{lstlisting}
dove la \lstinline|a_driver_ce| è:
\begin{lstlisting}[language=assembler, style=codestyle]	
a_driver_ce:
	call salva_stato
	movq $0, %rdi
	call c_driver_ce
	call apic_send_EOI
	call carica_stato
	iretq
\end{lstlisting}

La \lstinline|c_ceread_n()| avrà invece la controparte assembler:
\begin{lstlisting}[language=assembler, style=codestyle]	
	.extern	c_ceread_n
a_ceread_n:
	% qui nessuno chiama salva_stato
	call c_ceread_n
	% qui nessuno chiama carica_stato
	iretq
\end{lstlisting}
Dove notiamo ancora meglio che praticamente si ha una semplice chiamata di funzione che ritorna con la \lstinline|IRETQ| invece che con la \lstinline|RET|. 

\end{document}
