
\documentclass[a4paper,11pt]{article}
\usepackage[a4paper, margin=8em]{geometry}

% usa i pacchetti per la scrittura in italiano
\usepackage[french,italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\frenchspacing 

% usa i pacchetti per la formattazione matematica
\usepackage{amsmath, amssymb, amsthm, amsfonts}

% usa altri pacchetti
\usepackage{gensymb}
\usepackage{hyperref}
\usepackage{standalone}

\usepackage{colortbl}

\usepackage{xstring}
\usepackage{karnaugh-map}

% imposta il titolo
\title{Appunti Calcolatori Elettronici}
\author{Luca Seggiani}
\date{2025}

% imposta lo stile
% usa helvetica
\usepackage[scaled]{helvet}
% usa palatino
\usepackage{palatino}
% usa un font monospazio guardabile
\usepackage{lmodern}

\renewcommand{\rmdefault}{ppl}
\renewcommand{\sfdefault}{phv}
\renewcommand{\ttdefault}{lmtt}

% circuiti
\usepackage{circuitikz}
\usetikzlibrary{babel}

% testo cerchiato
\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=2pt] (char) {#1};}}

% disponi il titolo
\makeatletter
\renewcommand{\maketitle} {
	\begin{center} 
		\begin{minipage}[t]{.8\textwidth}
			\textsf{\huge\bfseries \@title} 
		\end{minipage}%
		\begin{minipage}[t]{.2\textwidth}
			\raggedleft \vspace{-1.65em}
			\textsf{\small \@author} \vfill
			\textsf{\small \@date}
		\end{minipage}
		\par
	\end{center}

	\thispagestyle{empty}
	\pagestyle{fancy}
}
\makeatother

% disponi teoremi
\usepackage{tcolorbox}
\newtcolorbox[auto counter, number within=section]{theorem}[2][]{%
	colback=blue!10, 
	colframe=blue!40!black, 
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries, 
	title=Teorema~\thetcbcounter: #2, 
	#1
}

% disponi definizioni
\newtcolorbox[auto counter, number within=section]{definition}[2][]{%
	colback=red!10,
	colframe=red!40!black,
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries,
	title=Definizione~\thetcbcounter: #2,
	#1
}

% disponi codice
\usepackage{listings}
\usepackage[table]{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{codestyle}{
		backgroundcolor=\color{black!5}, 
		commentstyle=\color{codegreen},
		keywordstyle=\bfseries\color{magenta},
		numberstyle=\sffamily\tiny\color{black!60},
		stringstyle=\color{green!50!black},
		basicstyle=\ttfamily\footnotesize,
		breakatwhitespace=false,         
		breaklines=true,                 
		captionpos=b,                    
		keepspaces=true,                 
		numbers=left,                    
		numbersep=5pt,                  
		showspaces=false,                
		showstringspaces=false,
		showtabs=false,                  
		tabsize=2
}

\lstdefinestyle{shellstyle}{
		backgroundcolor=\color{black!5}, 
		basicstyle=\ttfamily\footnotesize\color{black}, 
		commentstyle=\color{black}, 
		keywordstyle=\color{black},
		numberstyle=\color{black!5},
		stringstyle=\color{black}, 
		showspaces=false,
		showstringspaces=false, 
		showtabs=false, 
		tabsize=2, 
		numbers=none, 
		breaklines=true
}


\lstdefinelanguage{assembler}{ 
  keywords={AAA, AAD, AAM, AAS, ADC, ADCB, ADCW, ADCL, ADD, ADDB, ADDW, ADDL, AND, ANDB, ANDW, ANDL,
        ARPL, BOUND, BSF, BSFL, BSFW, BSR, BSRL, BSRW, BSWAP, BT, BTC, BTCB, BTCW, BTCL, BTR, 
        BTRB, BTRW, BTRL, BTS, BTSB, BTSW, BTSL, CALL, CBW, CDQ, CLC, CLD, CLI, CLTS, CMC, CMP,
        CMPB, CMPW, CMPL, CMPS, CMPSB, CMPSD, CMPSW, CMPXCHG, CMPXCHGB, CMPXCHGW, CMPXCHGL,
        CMPXCHG8B, CPUID, CWDE, DAA, DAS, DEC, DECB, DECW, DECL, DIV, DIVB, DIVW, DIVL, ENTER,
        HLT, IDIV, IDIVB, IDIVW, IDIVL, IMUL, IMULB, IMULW, IMULL, IN, INB, INW, INL, INC, INCB,
        INCW, INCL, INS, INSB, INSD, INSW, INT, INT3, INTO, INVD, INVLPG, IRET, IRETD, JA, JAE,
        JB, JBE, JC, JCXZ, JE, JECXZ, JG, JGE, JL, JLE, JMP, JNA, JNAE, JNB, JNBE, JNC, JNE, JNG,
        JNGE, JNL, JNLE, JNO, JNP, JNS, JNZ, JO, JP, JPE, JPO, JS, JZ, LAHF, LAR, LCALL, LDS,
        LEA, LEAVE, LES, LFS, LGDT, LGS, LIDT, LMSW, LOCK, LODSB, LODSD, LODSW, LOOP, LOOPE,
        LOOPNE, LSL, LSS, LTR, MOV, MOVB, MOVW, MOVL, MOVSB, MOVSD, MOVSW, MOVSX, MOVSXB,
        MOVSXW, MOVSXL, MOVZX, MOVZXB, MOVZXW, MOVZXL, MUL, MULB, MULW, MULL, NEG, NEGB, NEGW,
        NEGL, NOP, NOT, NOTB, NOTW, NOTL, OR, ORB, ORW, ORL, OUT, OUTB, OUTW, OUTL, OUTSB, OUTSD,
        OUTSW, POP, POPL, POPW, POPB, POPA, POPAD, POPF, POPFD, PUSH, PUSHL, PUSHW, PUSHB, PUSHA, 
				PUSHAD, PUSHF, PUSHFD, RCL, RCLB, RCLW, MOVSL, MOVSB, MOVSW, STOSL, STOSB, STOSW, LODSB, LODSW,
				LODSL, INSB, INSW, INSL, OUTSB, OUTSL, OUTSW
        RCLL, RCR, RCRB, RCRW, RCRL, RDMSR, RDPMC, RDTSC, REP, REPE, REPNE, RET, ROL, ROLB, ROLW,
        ROLL, ROR, RORB, RORW, RORL, SAHF, SAL, SALB, SALW, SALL, SAR, SARB, SARW, SARL, SBB,
        SBBB, SBBW, SBBL, SCASB, SCASD, SCASW, SETA, SETAE, SETB, SETBE, SETC, SETE, SETG, SETGE,
        SETL, SETLE, SETNA, SETNAE, SETNB, SETNBE, SETNC, SETNE, SETNG, SETNGE, SETNL, SETNLE,
        SETNO, SETNP, SETNS, SETNZ, SETO, SETP, SETPE, SETPO, SETS, SETZ, SGDT, SHL, SHLB, SHLW,
        SHLL, SHLD, SHR, SHRB, SHRW, SHRL, SHRD, SIDT, SLDT, SMSW, STC, STD, STI, STOSB, STOSD,
        STOSW, STR, SUB, SUBB, SUBW, SUBL, TEST, TESTB, TESTW, TESTL, VERR, VERW, WAIT, WBINVD,
        XADD, XADDB, XADDW, XADDL, XCHG, XCHGB, XCHGW, XCHGL, XLAT, XLATB, XOR, XORB, XORW, XORL},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{\#},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{language=assembler, style=codestyle}

% disponi sezioni
\usepackage{titlesec}

\titleformat{\section}
	{\sffamily\Large\bfseries} 
	{\thesection}{1em}{} 
\titleformat{\subsection}
	{\sffamily\large\bfseries}   
	{\thesubsection}{1em}{} 
\titleformat{\subsubsection}
	{\sffamily\normalsize\bfseries} 
	{\thesubsubsection}{1em}{}

% tikz
\usepackage{tikz}

% float
\usepackage{float}

% grafici
\usepackage{pgfplots}
\pgfplotsset{width=10cm,compat=1.9}

% disponi alberi
\usepackage{forest}

\forestset{
	rectstyle/.style={
		for tree={rectangle,draw,font=\large\sffamily}
	},
	roundstyle/.style={
		for tree={circle,draw,font=\large}
	}
}

% disponi algoritmi
\usepackage{algorithm}
\usepackage{algorithmic}
\makeatletter
\renewcommand{\ALG@name}{Algoritmo}
\makeatother

% disponi numeri di pagina
\usepackage{fancyhdr}
\fancyhf{} 
\fancyfoot[L]{\sffamily{\thepage}}

\makeatletter
\fancyhead[L]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@title \ \@date}}} 
\fancyhead[R]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@author}}}
\makeatother

\begin{document}
% sezione (data)
\section{Lezione del 24-03-25}

% stili pagina
\thispagestyle{empty}
\pagestyle{fancy}

% testo
\subsection{Primitive}
Abbiamo introdotto il concetto di primitiva, cioè di routine svolte dal sistema al servizio di un dato programma.
Queste verranno implementate come gestori di interruzioni, quindi non propriamente funzioni, in quanto implicano un passaggio di contesto.
Ciò nonostante, in un linguaggio come il C++ le primitive saranno comunque rappresentate da funzioni, dette \textit{funzioni interfaccia}, scritte in assembly e che hanno il solo compito di usare la funzione \lstinline|INT| con i parametri necessari alla chiamata di una specifica primitiva primitiva.

\subsubsection{Primitiva di creazione di un processo}
Abbiamo visto che la creazione di un processo consiste nell'inizializzazione dalla memoria ad esso dedicata in contesto utente e sistema, alla creazione del suo descrittore e all'inserzione di questo in pila \textit{"pronti"}.
Se la pila è rappresentata come una linked list, l'operazione dovra quindi essere quella di un \textit{inserimento in testa}.

Notiamo che questa operazione non può essere divisa da altre interruzioni, in quanto richiede necessariamente almeno due passaggi, dove fra un passaggio e l'altro la lista viene lasciata in uno stato inconsistente:
\begin{itemize}
	\item Prima si fa puntare il processo al resto della lista;
	\item Poi si fa puntare il puntatore della lista pronti al processo inserito.
\end{itemize}
anche invertendo l'ordine delle operazioni, dopo la prima la lista è inconsistente (in questo caso perché il processo inserito non viene effettivamente visto, nel caso opposto perché non vengono visti tutti gli altri).

Nel caso di routine di sistema basterà abbassare il flag \lstinline|IF|, disabilitando effettivamente le interruzioni, durante tutta la durata della routine.
A questo punto basterà evitare di generare eccezioni, e non usare mai l'istruzione \lstinline|INT|, per ottenere una routine che viene eseguita dal processore nella sua interezza senza il rischio di interruzioni.
Chiamiamo codice di questo tipo \textbf{codice atomico}.
Il kernel Linux, ad esempio, \textit{non} è atomico.

\subsubsection{Disposizione delle primitive}
La memoria del calcolatore conterrà in qualsiasi momento la tabella IDT, di cui abbiamo detto le prime 32 entrate rappresentano le eccezioni.
Siamo quindi liberi di usare i gate dal 33 in poi per implementare le primitive.
Per queste primitive dobbiamo impostare i parametri:
\begin{itemize}
	\item \textbf{P:} 1, per attivare il gate;
	\item \textbf{L:} sistema, in quanto le primitive devono essere svolte a livello sistema;
	\item \textbf{DPL:} utente, in quanto le primitive devono essere accessibili all'utente;
	\item L'indirizzo effettivo della routine, implementata (in assembly, serve \lstinline|IRET|), che deve trovarsi da qualche altra parte;
	\item \textbf{I/T:} tipo interrupt (interruzioni esterne mascherabili disabilitate).
\end{itemize}

Notiamo che l'interruzione esterna non mascherabile 2 è comunque in grado di bloccare le nostre istruzioni atomiche.
Questo non è importante, in quanto abbiamo detto la useremo per casi particolarmente catastrofici (dove magari la salvaguardia dei dati dell'utente e del sistema e di maggiore priorità rispetto allo stato dei processi).

La struttura della routine sarà quindi tipicamente:
\begin{lstlisting}[language=assembler, style=codestyle]	
primitiva:
	CALL salva_stato
	CALL c_primitiva
	CALL carica_stato
	IRETQ
\end{lstlisting}

dove \lstinline|c_primitiva| è una funzione, scritta in C++, che termina con una \lstinline|RET| e lascia quindi che \lstinline|primitiva| restituisca il controllo all'utente con \lstinline|IRETQ|.

Per chiamare la primitiva da C++, come abbiamo detto, ci doteremo di una funzione di interfaccia del tipo:
\begin{lstlisting}[language=assembler, style=codestyle]	
primitiva_i:
	INT $ tipo %il tipo di primitiva 
	RET
\end{lstlisting}

\subsubsection{Passaggio di parametri alla primitiva}
Supponiamo di voler passare dei parametri alla nostra primitiva.
La funzione di interfaccia dovrà semplicemente essere modificata per accettare dati parametri (\lstinline|primitiva_i(params...)|).

A questo punto la \lstinline|primitiva_i| potrà svolgere il passaggio effettivo sfruttando i registri, solitamente il solo registro \lstinline|%EAX| (in quanto \lstinline|salva_stato| non modifica i registri).

\subsubsection{Passaggio di parametri dalla primitiva}
Per avere una restituzione di parametri da parte della primitiva la situazione è più complicata, in quanto abbiamo una chiamata a \lstinline|carica_stato| prima del ritorno della primitiva per \lstinline|IRETQ|.

Abbiamo però accesso al contesto di processo, nel descrittore di processo, e possiamo quindi modificare i registri che ci interessano direttamente lì.

\subsubsection{Implementazione delle primitive processo}
Vediamo quindi l'implementazione effettiva delle primitive relative a creazione e terminazione dei processi, cioè le \lstinline|activate_p| e \lstinline|terminate_p|.
Queste chiaramente vengono chiamate da un handler scritto in assembly, che si occupa di salvare e caricare il contesto correttamente, in modo da non intaccare i registri in uso dal processo in \lstinline|esecuzione|.

\begin{itemize}
	\item \lstinline|activate_p|: questa sfrutta una funzione, \lstinline|crea_processo| (per adesso non significativa), che si occupa di creare effettivamente il descrittore di processo.
		Il suo compito è quindi solo quello di controllare che i parametri siano validi, chiamare \lstinline|crea_processo()|, inserire il descrittore in lista pronti e restituire l'id del processo creato.
\begin{lstlisting}[language=C++, style=codestyle]	
// crea un nuovo processo
extern "C" void c_activate_p(void f(natq), natq a, natl prio, natl liv)
{
	des_proc* p; // descrittore per il nuovo processo
	natl id = 0xFFFFFFFF; // id da restituire in caso di fallimento

	// seguono controlli di sicurezza sul livello
	[...]

	// crea effettivamente il descrittore di processo
	p = crea_processo(f, a, prio, liv);

	if (p != nullptr) {
		inserimento_lista(pronti, p);
		processi++;
		id = p->id;			// id del processo creato
						        // (allocato da crea_processo)
	}

	esecuzione->contesto[I_RAX] = id; // restituisci l'id del processo
}
\end{lstlisting}
\item \lstinline|terminate_p|: questa viene chiamata direttamente dal processo in \lstinline|esecuzione|, quando questo desidera essere terminato. 
	In questo, sfrutta una funzione, \lstinline|distruggi_processo()| (anche questa al momento non significativa), che si occupa di ripulire il descrittore del processo (e quindi la sua pila, ecc...).
\begin{lstlisting}[language=C++, style=codestyle]	
// termina il processo attuale 
extern "C" void c_terminate_p()
{
	des_proc* p = esecuzione;

	distruggi_processo(p);
	processi--;
	schedulatore();
}
\end{lstlisting}
\end{itemize}

\subsection{Semafori}
Per gestire l'accesso condiviso ad una risorsa, nel nostro kernel adotteremo il meccanismo dei \textbf{semafori}.

Introdotti da Dijsktra nel 1962, questi si possono meglio modellizzare come una scatola piena di gettoni: ogni utente può mettere un gettone o prelevare un gettone dalla scatola, con la condizione che questa operazione sia atomica: se si tenta di prendere un gettone che non esiste, si resta in attesa finché quel gettone non viene effettivamente immesso nella scatola.

I problemi che vogliamo risolvere sfruttando i semafori sono effettivamente die due categorie:
\begin{itemize}
	\item Problemi di \textbf{mutua esclusione:} assicurarsi che solo un processo possa accedere ad una risorsa in un dato momento.

		In questo caso si associa un gettone alla risorsa: accedere alle risorsa significa prendere il gettone, restituire la risorsa significa reinserire il gettone. L'esistenza di un singolo gettone assicura che solo un processo abbia accesso alla risorsa in un dato momento.
		Al momento della reimmissione del gettone, il processo che ne vince l'accesso sarà nel nostro kernel quello a priorità più alta.

		Notiamo inoltre che un processo che cerca di estrarre un gettone da una scatola vuota (tenta l'accesso ad una risorsa occupata o comunque non disponible) dovrà aspettare che questa risorsa si renda disponibile: rappresenterà quindi il caso perfetto di \textbf{blocco} del processo, che può essere realizzato con \textbf{preemption} nei sistemi che la supportoìano;

	\item Problemi di \textbf{sincronizzazione:} esistono più attività, e ci interessa che alcune attività vengano fatte prime di altre (ordinamento \textit{parziale}).

		Prendiamo l'esempio di avere due processi, A e B, e di volerci assicurare che $\text{A} \rightarrow \text{B}$.
		In questo caso creiamo un semaforo associato al processo A, che parte vuoto. A mette il suo gettone nel semaforo quando finisce la sua esecuzione.
		A questo punto, B preleva il gettone ed esegue.
		Se B avesse provato ad entrare in esecuzione prima che A avesse terminato, non sarebbe riuscito a prelevare il gettone e avrebbe fallito.

		Nel caso di 2 processi (sempre A e B, con A che scrive e B che legge) che devono scambiare dati fra di loro ciclicamente, potremmo usare 2 semafori per realizzare un \textit{handshake}.
		Ad esempio, definiamo quelle che effettivamente sono due variabili logiche sfruttando i semafori, che intendiamo come "buffer scritto" e "buffer letto".
		Il processo A dovrà semplicemente attivare il semaforo "buffer scritto" in fase di scrittura, e il processo B attivare il semaforo "buffer letto" in fase di lettura.
		Abbassando questi semafori al termine delle rispettive operazioni, e assicurandosi, osservando l'altro semaforo, di poter effettivamente procedere ad una nuova operazione, potremmo realizzare il paradigma desiderato. 
\end{itemize}

Dal punto di vista di implementazione, il kernel fornisce una primitiva \lstinline|sem_ini(int val)| che inizializza un semaforo con \lstinline|val| gettoni iniziali, restituendone l'indirizzo.
Da qui in poi i processi hanno accesso alle primitive \lstinline|sem_wait()| e \lstinline|sem_signal()|, che si occupano rispettivamente di richiedere e restiture un gettone.

\subsubsection{Implementazione delle primitive semaforiche}
Vediamo quindi l'implementazione delle primitive relative ai semafori, \lstinline|sem_ini()| \lstinline|sem_wait()| e \lstinline|sem_signal()|.

Innanzitutto, un semaforo viene descritto dalla struttura:
\begin{lstlisting}[language=C++, style=codestyle]	
// descrittore di semaforo
struct des_sem {
	// se >= 0, numero di gettoni contenuti;
	// se < 0, il valore assoluto e' il numero di processi in coda
	int counter;
	// coda di processi bloccati sul semaforo
	des_proc* pointer;
};
\end{lstlisting}

Si definisce quindi, sulla base di un paramero \lstinline|MAX_SEM| che definisce il numero massimo di semaforo in ogni contesto:
\begin{lstlisting}[language=C++, style=codestyle]	
des_sem array_dess[MAX_SEM * 2];
\end{lstlisting}

Il \lstinline|* 2| è motivato dal fatto che si forniscono due array separate di semafori, una al contesto utente e una al contesto sistema.

L'array dei semafori non viene mai ripulita, e i semafori correntemente attivi vengono mantenuti invece da due indici:
\begin{lstlisting}[language=C++, style=codestyle]	
// numero di semafori allocati per il livello utente
natl sem_allocati_utente  = 0;

// numero di semafori allocati per il livello sistema (moduli sistema e I/O)
natl sem_allocati_sistema = 0;
\end{lstlisting}

Le primitive vere e proprie sono quindi:
\begin{itemize}
	\item \lstinline|sem_ini()|: questa si serve di una funzione, \lstinline|alloca_sem()|, che svolge gli opportuni controlli e incrementa l'indice nel vettore dei semafori corretto:
\begin{lstlisting}[language=C++, style=codestyle]
// alloca un semaforo
natl alloca_sem()
{
	// i semafori non vengono mai deallocati, quindi e' possibile allocarli
	// sequenzialmente. Per far questo e' sufficiente ricordare quanti ne
	// abbiamo gia' allocati (variabili sem_allocati_utente e
	// sem_allocati_sistema)

	int liv = liv_chiamante();
	natl i;
	if (liv == LIV_UTENTE) { // semaforo utente
		if (sem_allocati_utente >= MAX_SEM)
			return 0xFFFFFFFF;
		i = sem_allocati_utente;
		sem_allocati_utente++;
	} else { // semaforo sistema
		if (sem_allocati_sistema >= MAX_SEM)
			return 0xFFFFFFFF;
		i = sem_allocati_sistema + MAX_SEM;
		sem_allocati_sistema++;
	}
	return i;
}

// inizializza un semaforo
extern "C" void c_sem_ini(int val)
{
	natl i = alloca_sem();

	if (i != 0xFFFFFFFF)
		array_dess[i].counter = val;

	esecuzione->contesto[I_RAX] = i;
}
\end{lstlisting}
	\item \lstinline|sem_wait()|: è semplicemente:
\begin{lstlisting}[language=C++, style=codestyle]	
extern "C" void c_sem_wait(natl sem)
{
	// controlli sulla validita' del semaforo
	[...]

	des_sem* s = &array_dess[sem];
	s->counter--;

	if (s->counter < 0) {
		inserimento_lista(s->pointer, esecuzione);
		schedulatore();
	}
}
\end{lstlisting}
	\item \lstinline|sem_signal()|: una particolarità di questa è l'uso della funzione \lstinline|inspronti()|, che si rende necessario, come avevamo detto, per non svantaggiare inutilmente il processo corrente alla chiamata di \lstinline|schedulatore()|:
\begin{lstlisting}[language=C++, style=codestyle]	
extern "C" void c_sem_signal(natl sem)
{
	// controlli sulla validita' del semaforo
	[...]

	des_sem* s = &array_dess[sem];
	s->counter++;

	if (s->counter <= 0) {
		des_proc* lavoro = rimozione_lista(s->pointer);
		inspronti();	// preemption
		inserimento_lista(pronti, lavoro);
		schedulatore();	// preemption
	}
}
\end{lstlisting}
\end{itemize}

\end{document}
